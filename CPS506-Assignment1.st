Object subclass: #Game	instanceVariableNames: 'gameBoard gamePieces gameSequence positionRows positionColumns currentPiece powerRows powerColumns'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS506-Assignment1'!!Game commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Game methodsFor: 'initialization' stamp: 'dark 9/28/2017 16:18'!initialize	"4 x 4 is the smallest size to fit at least one piece. "	gameBoard := Matrix rows:4 columns:4.	gamePieces := 0.	currentPiece := GamePieces new.			! !!Game methodsFor: 'instance creation' stamp: 'dark 9/29/2017 04:54'!board: columns and: rows	"creates clear board, add 1 and 2 to rows and columns to draw borders "	|newBoard boardRows boardColumns|		boardRows := rows+1.	boardColumns := columns+2.		newBoard := Matrix rows:boardRows columns:boardColumns.	newBoard atAllPut: Character space .		newBoard at:boardRows at:1 put:$+ ;at:boardRows at:boardColumns put:$+.		1 to: boardRows-1 do:[ :i| newBoard at:i at:1 put:$|; at:i at:boardColumns put:$|].	2 to: boardColumns-1 do:[:j| newBoard at:boardRows at:j put:$-].		gameBoard := newBoard.! !!Game methodsFor: 'instance creation' stamp: 'dark 10/5/2017 15:55'!dice: aSequence	"inserts sequence as an array"		gameSequence := aSequence		! !!Game methodsFor: 'instance creation' stamp: 'dark 10/4/2017 04:53'!readFrom: aReadStream	| lineStream aStream command arguments |	aStream := aReadStream readStream.	[ aStream position < aStream size ]		whileTrue: [ lineStream := (aStream upTo: Character cr) readStream.			command := lineStream upTo: $ .			arguments := OrderedCollection new.			[ lineStream position < lineStream size ] whileTrue: [ arguments add: (lineStream upTo: $ ) ].			(command match: 'board')				ifTrue: [ self board: (arguments contents at: 1) asNumber and: (arguments contents at: 2) asNumber ].			(command match: 'dice')				ifTrue: [ self						dice: arguments;						generatePiece;						dropPiece: currentPiece currentPiece ].			(command match: 'moves')				ifTrue: [ self move: arguments ].			(command match: 'powerup')				ifTrue: [ self powerUp: (arguments contents at: 1) asNumber at: (arguments contents at: 2) asNumber ] ].	(gameBoard at: powerRows at: powerColumns) = Character space				ifTrue: [ gameBoard at: powerRows at: powerColumns put: 'x' ].  ! !!Game methodsFor: 'printing' stamp: 'dark 10/5/2017 16:00'!printBoard	"writestream object for board"	| aStream aString |	aStream := (String new: gameBoard size) writeStream.	aString := ' Pieces: ' , gamePieces asString.	1 to: gameBoard numberOfRows do: [ :j | 		1 to: gameBoard numberOfColumns do: [ :i | 			aStream nextPutAll: (gameBoard at: j at: i) asString].					j = 1			ifTrue: [ aStream nextPutAll: aString ].		aStream cr ].	aString := aStream contents.	^ aString! !!Game methodsFor: 'printing' stamp: 'dark 10/5/2017 16:00'!printOn: aStream	"prints on selected stream"	aStream == String ifTrue:[^self printBoard fullPrintString].	aStream == Transcript ifTrue:[Transcript show:self printBoard].	! !!Game methodsFor: 'checking' stamp: 'dark 10/5/2017 15:55'!checkCell:r at: c with: moveR at: moveC"checks cell at given r and c with moveR/C to ensure if the move is valid"	|skip|	skip:=false.(r-(positionRows-3)+moveR)=5	ifTrue:[skip := true].(c-(positionColumns-2)+moveC)=5	ifTrue:[skip :=true].					(gameBoard at: r+moveR at:c+moveC)=(Character space)		ifTrue:[^true]		ifFalse:[			(skip)ifFalse:[			(gameBoard at: r+moveR at: c+moveC)=(currentPiece currentPiece at:(r-(positionRows-3)+moveR) at:(c-(positionColumns-2)+moveC))				ifTrue:[^true]].				^false]. 	! !!Game methodsFor: 'checking' stamp: 'dark 10/5/2017 15:54'!check"loops through current pieces cells to check for valid move"	|counter|	counter:=true.	positionRows = (gameBoard numberOfRows-1)		ifTrue: [ ^ false ].	positionRows + 1 to: positionRows - 2 by: -1 do: [ :r | 		positionColumns - 1 to: positionColumns + 2 do: [ :c | 			(currentPiece currentPiece at:(r-(positionRows-3)) at:(c-(positionColumns-2)))=Character space 					ifFalse:[ counter := self checkCell: r at: c with: 1  at: 0.							counter								ifFalse:[^false]]]]. 					^(counter)			! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/3/2017 23:55'!generatePiece	"uses dice command to generate piece. Will also access the gamePieces field and increment for each piece generated"	| roll aMatrix|	gamePieces := (gamePieces + 1)asNumber.	positionRows := 2.	positionColumns := (gameBoard numberOfColumns//2).	roll := (self diceRoll)asNumber.	aMatrix := GamePieces new generate:roll.	(self diceRotate > 1)ifTrue:[ 	aMatrix rotateLeft ].	(aMatrix currentPiece at: 1 at: 2) = Character space	ifFalse:[positionRows:=3].		currentPiece := aMatrix.! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:56'!diceRotate	"returns number for rotation according to the game sequence using the number of pieces + 1"	^(gameSequence atWrap:(gamePieces+((gamePieces-1)*1))+1)asNumber.! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 16:00'!powerUp: column at: row	"stores location of power up"	|bottomRow|	bottomRow := gameBoard numberOfRows - row -1. 		powerRows := bottomRow.	powerColumns := column+1.	! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:59'!powerUp	"boolean to invoke power up"	|counter|		counter:=false.	positionRows+1 to: positionRows-2 by:-1 do:[:r|		positionColumns-1 to: positionColumns+2 do:[:c|			(currentPiece currentPiece at:r-(positionRows-3) at:c-(positionColumns-2))=Character space 					ifFalse:[			r=powerRows				ifTrue:[counter := true].			c=powerColumns				ifTrue:[counter := true]]]].	^(counter).	! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:56'!diceRoll	"returns value of sequence relative to the number of game pieces"	^gameSequence atWrap: (gamePieces+((gamePieces-1)*1)).		  ! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:57'!dropPiece: aMatrix	"from the current selected piece this method will add the piece to the board"	| shiftUp |	shiftUp := 0.	positionRows = 2		ifTrue: [ shiftUp := 1 ].	positionRows + 1 to: positionRows - 2 + shiftUp by: -1 do: [ :r | 		positionColumns - 1 to: positionColumns + 2 do: [ :c | 			(currentPiece currentPiece at: r - (positionRows - 3)at: c - (positionColumns - 2)) = Character space				ifFalse: [ (gameBoard at: r at: c) = Character space						ifTrue: [ 							gameBoard at: r at: c put: (aMatrix at: r - (positionRows - 3) at: c - (positionColumns - 2)) ] ] ] ]! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:59'!moveCell:r at:c with:moveR at:moveC"moves individual cell of current piece"(gameBoard at:r+moveR at:c+moveC)=Character space 	ifTrue:[gameBoard swap:r+moveR at: c+moveC with: r at: c]. ! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 16:01'!rotatePiece: aDirection	"rotates current piece to given direction"	| checkMatrix command shiftUp|	shiftUp:=0.	positionRows = 2		ifTrue:[shiftUp:=1].			checkMatrix := GamePieces new.	checkMatrix := currentPiece.	command := aDirection readStream next.	positionRows + 1 to: positionRows - 2 +shiftUp by: -1 do: [ :r | 		positionColumns - 1 to: positionColumns + 2 do: [ :c | 						(currentPiece currentPiece at: r - (positionRows - 3) at: c - (positionColumns - 2)) = Character space				ifFalse: [  gameBoard at: r at: c put: Character space ]. ] ].		command = $L		ifTrue: [ checkMatrix rotateLeft ].	command = $R		ifTrue: [ checkMatrix rotateRight ].	self dropPiece: checkMatrix currentPiece.	currentPiece := checkMatrix! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 15:58'!lineDrop: aRowNumber 	"recursively pass the clear line to the top the board"	aRowNumber to: 2  by:-1 do: [ :each|gameBoard swapRow:each withRow:each-1. ]	! !!Game methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 16:01'!movePieceTo: moveR at: moveC	"checks current piece and moves piece to designated direction moveR/C"	| switch lSide rSide |	lSide := positionColumns - 1.	rSide := positionColumns + 2.	switch := 1.	moveC = 1		ifTrue: [ lSide := positionColumns + 2.			rSide := positionColumns - 1.			switch := -1 ].	positionRows + 1 to: positionRows - 2 by: -1 do: [ :r | 		lSide to: rSide by: switch do: [ :c | 			(currentPiece currentPiece at: r - (positionRows - 3) at: c - (positionColumns - 2)) = Character space				ifFalse: [ r = 0						ifFalse: [ r = 11								ifFalse: [ c = 0										ifFalse: [ self moveCell:r at:c with:moveR at: moveC ] ] ] ] ] ]. (positionRows = (gameBoard numberOfRows -1) )ifFalse:[positionRows := positionRows + moveR].											(positionColumns = 2)	ifFalse:[(positionColumns = (gameBoard numberOfColumns -1))		ifFalse:[positionColumns := positionColumns + moveC]]! !!Game methodsFor: 'accessing' stamp: 'dark 10/5/2017 15:57'!lineCheck	"checks board for full lines, if true executes line clear method" 	|r1 r2 c1 c2 counter|		r2:= gameBoard numberOfRows -1.	r1:= 1.		c1:= 2.	c2:= gameBoard numberOfColumns -1.		r1 to: r2 do:[:r|		counter:=true.		c1 to: c2 do:[:c|						(gameBoard at:r at:c)=Character space				ifTrue:[counter:=false]].			counter				ifTrue:[self lineClear:r].				]														! !!Game methodsFor: 'accessing' stamp: 'dark 10/5/2017 15:58'!move: arguments	"reads from the readFrom and executes moves accordingly"	| moveR moveC aReadStream command |	1 to: arguments size do: [ :each | 		aReadStream := (arguments at: each) readStream.		[ aReadStream position < aReadStream size ]			whileTrue: [ command := aReadStream next.				self powerUp 						ifFalse:[(gameBoard at:powerRows at: powerColumns)=Character space 								ifTrue:[						gameBoard at:powerRows at: powerColumns put:'x']].				moveR := 0.				moveC := 0.				command = $.					ifTrue: [ moveR := 1 ].				command = $l					ifTrue: [ moveC := -1 ].				command = $r					ifTrue: [ moveC := 1 ].				command = $L					ifTrue: [ command := #(#'L').						self rotate: command ].				command = $R					ifTrue: [ command := #(#'R').						self rotate: command ].				command = $+					ifTrue: [ [ self check ]							whileTrue: [ command := #(#'.').								self move: command ] ].										self check					ifFalse: [ self							generatePiece;							dropPiece: currentPiece currentPiece ].				self movePieceTo: moveR at: moveC.				self lineCheck. ] ]! !!Game methodsFor: 'accessing' stamp: 'dark 10/5/2017 15:58'!lineClear: aRowNumber	"clears line at desginated row number and swaps out clear line to the top of the board"	|clearLine|	clearLine := Matrix rows: 1 columns: gameBoard numberOfColumns-2 .	clearLine atAllPut: Character space. 	gameBoard atRows:aRowNumber to: aRowNumber columns:2 to:gameBoard numberOfColumns-1 put:clearLine.	self lineDrop: aRowNumber.! !!Game methodsFor: 'accessing' stamp: 'dark 10/5/2017 16:01'!rotate: aDirection	"boolean to check if current piece can rotate on board"	| checkMatrix counter shiftUp command |	checkMatrix := GamePieces new.	command := aDirection readStream next.	counter := true.	shiftUp := 0.	command = $L		ifTrue: [ checkMatrix := currentPiece rotateLeft ].	command = $R		ifTrue: [ checkMatrix := currentPiece rotateRight ].	positionRows = 2		ifTrue: [ shiftUp := 1 ].	positionRows + 1 to: positionRows - 2 + shiftUp by: -1 do: [ :r | 		positionColumns - 1 to: positionColumns + 2 do: [ :c | 			(checkMatrix currentPiece at: r - (positionRows - 3) at: c - (positionColumns - 2)) = Character space				ifFalse: [ (gameBoard at: r at: c) = Character space						ifFalse: [ (gameBoard at: r at: c) = (checkMatrix currentPiece at: r - (positionRows - 3) at: c - (positionColumns - 2))								ifFalse: [ counter := false ] ] ] ] ].	counter		ifTrue: [ self rotatePiece: command ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Game class	instanceVariableNames: 'gameBoard totalPieces gamePieces'!Object subclass: #GamePieces	instanceVariableNames: 'gamePiece'	classVariableNames: ''	poolDictionaries: ''	category: 'CPS506-Assignment1'!!GamePieces commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!GamePieces methodsFor: 'as yet unclassified' stamp: 'dark 10/4/2017 01:03'!rotateRight	| rotatePiece |	rotatePiece := Matrix new: 4.	rotatePiece atAllPut: Character space.	rotatePiece		at: 1 at: 2 put: (gamePiece at: 3 at: 4);		at: 2 at: 1 put: (gamePiece at: 2 at: 3);		at: 2 at: 2 put: (gamePiece at: 3 at: 3);		at: 2 at: 3 put: (gamePiece at: 4 at: 3);		at: 3 at: 1 put: (gamePiece at: 2 at:2);		at: 3 at: 2 put: (gamePiece at: 3 at:2);		at: 3 at: 3 put: (gamePiece at: 4 at:2);		at: 3 at: 4 put: (gamePiece at: 1 at:2);		at: 4 at: 1 put: (gamePiece at: 2 at:1);		at: 4 at: 2 put: (gamePiece at: 3 at:1);		at: 4 at: 3 put: (gamePiece at: 4 at:1).	(gamePiece includes:'y') ifFalse:[		gamePiece := rotatePiece].! !!GamePieces methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 16:02'!rotateLeft	"rotation is done without matrix transformation, to preserve the state of the board"	| rotatePiece |	rotatePiece := Matrix new: 4.	rotatePiece atAllPut: Character space.	rotatePiece		at: 1 at: 2 put: (gamePiece at: 3 at: 4);		at: 2 at: 1 put: (gamePiece at: 4 at: 1);		at: 2 at: 2 put: (gamePiece at: 3 at: 1);		at: 2 at: 3 put: (gamePiece at: 2 at: 1);		at: 3 at: 1 put: (gamePiece at: 4 at:2);		at: 3 at: 2 put: (gamePiece at: 3 at:2);		at: 3 at: 3 put: (gamePiece at: 2 at:2);		at: 3 at: 4 put: (gamePiece at: 1 at:2);		at: 4 at: 1 put: (gamePiece at: 4 at:3);		at: 4 at: 2 put: (gamePiece at: 3 at:3);		at: 4 at: 3 put: (gamePiece at: 2 at:3).			(gamePiece includes:'y') ifFalse:[		gamePiece := rotatePiece].! !!GamePieces methodsFor: 'as yet unclassified' stamp: 'dark 10/5/2017 16:02'!currentPiece	"returns the matrix of the currentPiece"	^gamePiece! !!GamePieces methodsFor: 'translating' stamp: 'dark 10/2/2017 01:10'!generate: anInteger	"receives integer from 1-7 which coincides with piece to be generated"		| pieceNumber rotation|		pieceNumber := anInteger.			"yellow piece"	pieceNumber = 1		ifTrue: [ gamePiece  				at: 2 at: 2 put: 'y';				at: 2 at: 3 put: 'y';				at: 3 at: 2 put: 'y';				at: 3 at: 3 put: 'y' ].				"red piece"	pieceNumber = 2		ifTrue: [ gamePiece  				at: 2 at:1put:'r';				at: 2 at:2 put:'r';				at: 3 at:2 put:'r';				at: 3 at:3 put:'r'].	"green piece"	pieceNumber = 3		ifTrue: [ gamePiece 				at: 2 at:2 put:'g';				at: 2 at:3 put:'g';				at: 3 at:1 put:'g';				at: 3 at:2 put:'g'].	pieceNumber = 4		ifTrue: [ gamePiece 				at: 2 at:2 put:'b';				at: 3 at:1 put:'b';				at: 3 at:2 put:'b';				at: 3 at:3 put:'b'].	pieceNumber = 5		ifTrue: [ gamePiece  				at:2 at:3 put:'o';				at:3 at:1 put:'o';				at:3 at:2 put:'o';				at:3 at:3 put:'o'].	pieceNumber = 6		ifTrue: [ gamePiece 				at:2 at:2 put:'p';				at:3 at:1 put:'p';				at:3 at:2 put:'p';				at:3 at:3 put:'p'].	pieceNumber = 7		ifTrue: [ gamePiece  				at:3 at:1 put:'c';				at:3 at:2 put:'c';				at:3 at:3 put:'c';				at:3 at:4 put:'c'].					! !!GamePieces methodsFor: 'initialization' stamp: 'dark 9/27/2017 13:04'!initialize gamePiece := Matrix new:4. gamePiece atAllPut: Character space.! !